"""
Auto-generated Dagster pipeline for raw_ttb_ai
Generated by Inspector Dom
Entity Type: INTERIM
"""

from dagster import (
    asset,
    AssetExecutionContext,
    MaterializeResult,
    MetadataValue,
    RetryPolicy,
)
from typing import Dict, Any, List, Optional
import logging
import traceback
import re
from datetime import datetime

# Configure logging
logger = logging.getLogger(__name__)

# ============================================================================
# EXTRACTION ASSETS
# ============================================================================

@asset(
    name="extract_raw_ttb_ai",
    description="Extract data from source artifacts using template",
    compute_kind="extraction",
    retry_policy=RetryPolicy(max_retries=3),
)
def extract_raw_ttb_ai(context: AssetExecutionContext) -> Dict[str, Any]:
    """
    Extract raw_ttb_ai data from source artifacts.

    Strategy: template
    Entity Type: INTERIM
    """
    try:
        context.log.info(f"Starting extraction for raw_ttb_ai")

        # Initialize Supabase client
        from supabase import create_client
        import os

        supabase = create_client(
            os.getenv("NEXT_PUBLIC_SUPABASE_URL"),
            os.getenv("SUPABASE_SERVICE_ROLE_KEY")
        )

        # Fetch source artifacts
        source_ids = ["c127ef77-7633-45b3-92f6-aab50c489492","be9d98d6-eed8-4515-acf9-a75e0ba3e1b4"]

        query = supabase.table("artifacts").select("*")
        if source_ids:
            query = query.in_("source_id", source_ids)

        artifacts_response = query.execute()
        artifacts = artifacts_response.data

        context.log.info(f"Found {len(artifacts)} artifacts to process")

        # Extract data from each artifact
        extracted_records = []
        failed_count = 0

        for artifact in artifacts:
            try:
                record = extract_from_artifact(
                    artifact,
                    template_id="7e4d486a-44f0-4a4a-b6e1-a884b5b302af",
                    context=context
                )

                if record:
                    # Validate required fields
                    if validate_record(record, []):
                        extracted_records.append(record)
                    else:
                        context.log.warning(f"Validation failed for artifact {artifact['id']}")
                        failed_count += 1
                else:
                    failed_count += 1

            except Exception as e:
                context.log.error(f"Failed to extract artifact {artifact['id']}: {str(e)}")
                failed_count += 1
                continue

        success_rate = (len(extracted_records) / len(artifacts) * 100) if artifacts else 0

        context.log.info(
            f"Extraction complete: {len(extracted_records)} successful, "
            f"{failed_count} failed ({success_rate:.1f}% success rate)"
        )

        # Quality check: Alert if success rate is too low
        if success_rate < 80:
            context.log.warning(
                f"⚠️ Low extraction success rate: {success_rate:.1f}%. "
                f"Template may need adjustment."
            )

        return {
            "records": extracted_records,
            "metadata": {
                "total_artifacts": len(artifacts),
                "extracted": len(extracted_records),
                "failed": failed_count,
                "success_rate": success_rate,
            }
        }

    except Exception as e:
        context.log.error(f"Extraction failed: {str(e)}")
        context.log.error(traceback.format_exc())
        raise


def extract_from_artifact(
    artifact: Dict[str, Any],
    template_id: Optional[str],
    context: AssetExecutionContext
) -> Optional[Dict[str, Any]]:
    """
    Extract data from a single artifact using template or AI.
    """
    try:
        raw_content = artifact.get("raw_content", {})

        # Priority 1: AI-extracted fields
        if isinstance(raw_content, dict) and "fields" in raw_content:
            context.log.debug(f"Using AI-extracted fields for {artifact['id']}")
            return raw_content["fields"]

        # Priority 2: Template extraction from HTML text
        if isinstance(raw_content, dict) and "text" in raw_content:
            context.log.debug(f"Extracting from HTML text for {artifact['id']}")
            text = raw_content["text"]

            # Load template selectors if template_id provided
            template_selectors = None
            if template_id:
                try:
                    from supabase import create_client
                    import os
                    supabase = create_client(
                        os.getenv("NEXT_PUBLIC_SUPABASE_URL"),
                        os.getenv("SUPABASE_SERVICE_ROLE_KEY")
                    )
                    template_response = supabase.table("templates").select("selectors").eq("id", template_id).single().execute()
                    if template_response.data and template_response.data.get("selectors"):
                        template_selectors = template_response.data["selectors"]
                        context.log.debug(f"Loaded template selectors for template {template_id}")
                except Exception as e:
                    context.log.warning(f"Failed to load template selectors: {str(e)}")

            # Field extraction with template selectors
            extracted = {}
                        # Extract ttb_id
            # Try template selector first if available (check variations)
            selector_names = ["ttb_id","ttb"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["ttb_id"] = match.group(1).strip()
                        context.log.debug(f"Extracted ttb_id using template primary pattern")
                # Try fallback pattern if primary failed
                if "ttb_id" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["ttb_id"] = match.group(1).strip()
                        context.log.debug(f"Extracted ttb_id using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "ttb_id" not in extracted:
                match = re.search(r'TTB\s+ID\s*(\d+)', text, re.IGNORECASE)
                if match:
                    extracted["ttb_id"] = match.group(1).strip()
                    context.log.debug(f"Extracted ttb_id using basic pattern")
            # Extract ct_number
            # Try template selector first if available (check variations)
            selector_names = ["ct_number","ct"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["ct_number"] = match.group(1).strip()
                        context.log.debug(f"Extracted ct_number using template primary pattern")
                # Try fallback pattern if primary failed
                if "ct_number" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["ct_number"] = match.group(1).strip()
                        context.log.debug(f"Extracted ct_number using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "ct_number" not in extracted:
                match = re.search(r'\bCT\s*(\d+)', text, re.IGNORECASE)
                if match:
                    extracted["ct_number"] = match.group(1).strip()
                    context.log.debug(f"Extracted ct_number using basic pattern")
            # Extract or_number
            # Try template selector first if available (check variations)
            selector_names = ["or_number","or"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["or_number"] = match.group(1).strip()
                        context.log.debug(f"Extracted or_number using template primary pattern")
                # Try fallback pattern if primary failed
                if "or_number" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["or_number"] = match.group(1).strip()
                        context.log.debug(f"Extracted or_number using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "or_number" not in extracted:
                match = re.search(r'\bOR\s*(\d+)', text, re.IGNORECASE)
                if match:
                    extracted["or_number"] = match.group(1).strip()
                    context.log.debug(f"Extracted or_number using basic pattern")
            # Extract source_of_product
            # Try template selector first if available (check variations)
            selector_names = ["source_of_product"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["source_of_product"] = match.group(1).strip()
                        context.log.debug(f"Extracted source_of_product using template primary pattern")
                # Try fallback pattern if primary failed
                if "source_of_product" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["source_of_product"] = match.group(1).strip()
                        context.log.debug(f"Extracted source_of_product using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "source_of_product" not in extracted:
                match = re.search(r'source_of_product[:\s]+([^\n]+)', text, re.IGNORECASE)
                if match:
                    extracted["source_of_product"] = match.group(1).strip()
                    context.log.debug(f"Extracted source_of_product using basic pattern")
            # Extract plant_registry_number
            # Try template selector first if available (check variations)
            selector_names = ["plant_registry_number","plant_registry"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["plant_registry_number"] = match.group(1).strip()
                        context.log.debug(f"Extracted plant_registry_number using template primary pattern")
                # Try fallback pattern if primary failed
                if "plant_registry_number" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["plant_registry_number"] = match.group(1).strip()
                        context.log.debug(f"Extracted plant_registry_number using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "plant_registry_number" not in extracted:
                match = re.search(r'plant_registry_number[:\s]+([^\n]+)', text, re.IGNORECASE)
                if match:
                    extracted["plant_registry_number"] = match.group(1).strip()
                    context.log.debug(f"Extracted plant_registry_number using basic pattern")
            # Extract product_type
            # Try template selector first if available (check variations)
            selector_names = ["product_type"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["product_type"] = match.group(1).strip()
                        context.log.debug(f"Extracted product_type using template primary pattern")
                # Try fallback pattern if primary failed
                if "product_type" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["product_type"] = match.group(1).strip()
                        context.log.debug(f"Extracted product_type using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "product_type" not in extracted:
                match = re.search(r'TYPE\s+OF\s+PRODUCT[^A-Z]*(WINE|DISTILLED SPIRITS|MALT BEVERAGE)', text, re.IGNORECASE)
                if match:
                    extracted["product_type"] = match.group(1).strip()
                    context.log.debug(f"Extracted product_type using basic pattern")
            # Extract applicant_name
            # Try template selector first if available (check variations)
            selector_names = ["applicant_name"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["applicant_name"] = match.group(1).strip()
                        context.log.debug(f"Extracted applicant_name using template primary pattern")
                # Try fallback pattern if primary failed
                if "applicant_name" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["applicant_name"] = match.group(1).strip()
                        context.log.debug(f"Extracted applicant_name using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "applicant_name" not in extracted:
                match = re.search(r'applicant_name[:\s]+([^\n]+)', text, re.IGNORECASE)
                if match:
                    extracted["applicant_name"] = match.group(1).strip()
                    context.log.debug(f"Extracted applicant_name using basic pattern")
            # Extract applicant_address
            # Try template selector first if available (check variations)
            selector_names = ["applicant_address"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["applicant_address"] = match.group(1).strip()
                        context.log.debug(f"Extracted applicant_address using template primary pattern")
                # Try fallback pattern if primary failed
                if "applicant_address" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["applicant_address"] = match.group(1).strip()
                        context.log.debug(f"Extracted applicant_address using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "applicant_address" not in extracted:
                match = re.search(r'applicant_address[:\s]+([^\n]+)', text, re.IGNORECASE)
                if match:
                    extracted["applicant_address"] = match.group(1).strip()
                    context.log.debug(f"Extracted applicant_address using basic pattern")
            # Extract application_type
            # Try template selector first if available (check variations)
            selector_names = ["application_type"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["application_type"] = match.group(1).strip()
                        context.log.debug(f"Extracted application_type using template primary pattern")
                # Try fallback pattern if primary failed
                if "application_type" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["application_type"] = match.group(1).strip()
                        context.log.debug(f"Extracted application_type using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "application_type" not in extracted:
                match = re.search(r'application_type[:\s]+([^\n]+)', text, re.IGNORECASE)
                if match:
                    extracted["application_type"] = match.group(1).strip()
                    context.log.debug(f"Extracted application_type using basic pattern")
            # Extract status
            # Try template selector first if available (check variations)
            selector_names = ["status"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["status"] = match.group(1).strip()
                        context.log.debug(f"Extracted status using template primary pattern")
                # Try fallback pattern if primary failed
                if "status" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["status"] = match.group(1).strip()
                        context.log.debug(f"Extracted status using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "status" not in extracted:
                match = re.search(r'status[:\s]+([^\n]+)', text, re.IGNORECASE)
                if match:
                    extracted["status"] = match.group(1).strip()
                    context.log.debug(f"Extracted status using basic pattern")
            # Extract class_type_description
            # Try template selector first if available (check variations)
            selector_names = ["class_type_description"]
            field_selector = None
            if template_selectors and template_selectors.get("fields"):
                for sel_name in selector_names:
                    if sel_name in template_selectors["fields"]:
                        field_selector = template_selectors["fields"][sel_name]
                        break
            if field_selector:
                # Try primary pattern
                if "pattern" in field_selector and "primary" in field_selector["pattern"]:
                    pattern = field_selector["pattern"]["primary"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["class_type_description"] = match.group(1).strip()
                        context.log.debug(f"Extracted class_type_description using template primary pattern")
                # Try fallback pattern if primary failed
                if "class_type_description" not in extracted and "fallback" in field_selector.get("pattern", {}):
                    pattern = field_selector["pattern"]["fallback"]
                    match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                    if match:
                        extracted["class_type_description"] = match.group(1).strip()
                        context.log.debug(f"Extracted class_type_description using template fallback pattern")
            # Fallback to basic pattern if no template selector or template extraction failed
            if "class_type_description" not in extracted:
                match = re.search(r'class_type_description[:\s]+([^\n]+)', text, re.IGNORECASE)
                if match:
                    extracted["class_type_description"] = match.group(1).strip()
                    context.log.debug(f"Extracted class_type_description using basic pattern")

            return extracted if extracted else None

        # Priority 3: Use metadata
        if artifact.get("metadata", {}).get("extracted_data"):
            context.log.debug(f"Using metadata extraction for {artifact['id']}")
            return artifact["metadata"]["extracted_data"]

        return None

    except Exception as e:
        context.log.error(f"Extraction error for artifact {artifact['id']}: {str(e)}")
        return None


# ============================================================================
# TRANSFORMATION ASSETS
# ============================================================================

# No transformation needed for INTERIM entities
# Data flows directly to downstream Reference/Master entities


# ============================================================================
# LOAD ASSETS
# ============================================================================

@asset(
    name="load_raw_ttb_ai",
    description="Load transformed data into raw_ttb_ai table",
    compute_kind="load",
    deps=["extract_raw_ttb_ai"],
    retry_policy=RetryPolicy(max_retries=3),
)
def load_raw_ttb_ai(
    context: AssetExecutionContext,
    extract_raw_ttb_ai: Dict[str, Any]
) -> MaterializeResult:
    """
    Load raw_ttb_ai data into database.

    Target Table: raw_ttb_ai
    Entity Type: INTERIM
    """
    try:
        context.log.info(f"Starting load for raw_ttb_ai")

        # Initialize Supabase client
        from supabase import create_client
        import os

        supabase = create_client(
            os.getenv("NEXT_PUBLIC_SUPABASE_URL"),
            os.getenv("SUPABASE_SERVICE_ROLE_KEY")
        )

        records = extract_raw_ttb_ai["records"]

        if not records:
            context.log.warning("No records to load")
            return MaterializeResult(
                metadata={
                    "records_loaded": 0,
                    "records_failed": 0,
                }
            )

        # Batch insert with error handling
        batch_size = 100
        loaded_count = 0
        failed_count = 0

        for i in range(0, len(records), batch_size):
            batch = records[i:i + batch_size]

            try:
                response = supabase.table("raw_ttb_ai").insert(batch).execute()
                loaded_count += len(batch)
                context.log.info(f"Loaded batch {i//batch_size + 1}: {len(batch)} records")

            except Exception as e:
                context.log.error(f"Batch insert failed: {str(e)}")

                # Try inserting records one by one
                for record in batch:
                    try:
                        supabase.table("raw_ttb_ai").insert(record).execute()
                        loaded_count += 1
                    except Exception as record_error:
                        context.log.error(
                            f"Failed to insert record: {str(record_error)}"
                        )
                        failed_count += 1

        success_rate = (loaded_count / len(records) * 100) if records else 0

        context.log.info(
            f"Load complete: {loaded_count} loaded, {failed_count} failed "
            f"({success_rate:.1f}% success rate)"
        )

        # Quality check
        if success_rate < 95:
            context.log.warning(
                f"⚠️ Load success rate below 95%: {success_rate:.1f}%"
            )

        return MaterializeResult(
            metadata={
                "records_loaded": MetadataValue.int(loaded_count),
                "records_failed": MetadataValue.int(failed_count),
                "success_rate": MetadataValue.float(success_rate),
                "table_name": MetadataValue.text("raw_ttb_ai"),
            }
        )

    except Exception as e:
        context.log.error(f"Load failed: {str(e)}")
        context.log.error(traceback.format_exc())
        raise


# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def validate_record(record: Dict[str, Any], required_fields: List[str]) -> bool:
    """Validate that all required fields are present and non-empty."""
    for field in required_fields:
        if field not in record or record[field] is None or record[field] == "":
            return False
    return True


def deduplicate_records(
    records: List[Dict[str, Any]],
    key_fields: List[str]
) -> List[Dict[str, Any]]:
    """Remove duplicate records based on key fields."""
    seen = set()
    unique_records = []

    for record in records:
        # Create a key from specified fields
        key = tuple(record.get(field) for field in key_fields)

        if key not in seen:
            seen.add(key)
            unique_records.append(record)

    return unique_records


def parse_date(value: Any) -> Optional[str]:
    """Parse various date formats to ISO format."""
    if not value:
        return None

    import dateutil.parser

    try:
        if isinstance(value, str):
            dt = dateutil.parser.parse(value)
            return dt.date().isoformat()
        return str(value)
    except Exception:
        return None


def parse_timestamp(value: Any) -> Optional[str]:
    """Parse various timestamp formats to ISO format."""
    if not value:
        return None

    import dateutil.parser

    try:
        if isinstance(value, str):
            dt = dateutil.parser.parse(value)
            return dt.isoformat()
        return str(value)
    except Exception:
        return None

